<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Nostalgia Era: 18–30 (Morphing Cube)</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
        }

        #morphCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #scanlines2000s,
        #crtGlow2000s {
            position: fixed;
            inset: 0;
            pointer-events: none;
        }

        #scanlines2000s {
            background: repeating-linear-gradient(to bottom,
                    rgba(255, 255, 255, 0.04) 0px,
                    rgba(0, 0, 0, 0.1) 3px,
                    rgba(0, 0, 0, 0.1) 6px);
            animation: scanMove 0.15s linear infinite;
        }

        #crtGlow2000s {
            background: radial-gradient(circle at center,
                    rgba(255, 255, 255, 0.35) 0%,
                    rgba(255, 255, 255, 0.18) 20%,
                    rgba(255, 255, 255, 0.10) 40%,
                    rgba(0, 0, 0, 0.25) 70%,
                    rgba(0, 0, 0, 0.90) 100%);
        }

        #hud {
            position: fixed;
            top: 15px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 5;
            text-shadow: 0 0 5px black;
        }

        @keyframes scanMove {
            0% {
                background-position-y: 0px;
            }

            100% {
                background-position-y: 6px;
            }
        }

        #backBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 18px;
            background: magenta;
            color: black;
            font-family: Arial, sans-serif;
            font-size: 18px;
            text-decoration: none;
            border-radius: 8px;
            z-index: 9999;
            box-shadow: 0 0 10px magenta;
            transition: 0.2s;
        }

        #backBtn:hover {
            background: #ff80ff;
            box-shadow: 0 0 14px #ff80ff;
        }
    </style>
</head>

<body>
    <div id="hud">
        <div><b>Nostalgia Era: 18–30</b></div>
        <div>Drag with mouse to rotate • Watch it morph</div>
    </div>
    <a href="/" id="backBtn">← Home</a>
    <canvas id="morphCanvas"></canvas>
    <div id="scanlines2000s"></div>
    <div id="crtGlow2000s"></div>

    <!-- Sound -->
    <audio id="nos2" src="/static/nos2.mp3" loop></audio>

    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script>
        let morphRenderer, morphScene, morphCamera, morphMesh, morphClock;
        let morphDrag = false;
        let morphLastX = 0, morphLastY = 0;

        function initMorph() {
            const canvas = document.getElementById("morphCanvas");
            morphRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            resizeRenderer();

            morphScene = new THREE.Scene();
            morphCamera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            morphCamera.position.z = 4;

            morphClock = new THREE.Clock();

            const segments = 20;
            const baseGeom = new THREE.BoxGeometry(2, 2, 2, segments, segments, segments);
            const basePos = baseGeom.attributes.position;

            const flatPos = basePos.clone();
            for (let i = 0; i < flatPos.count; i++) {
                const x = basePos.getX(i);
                const z = basePos.getZ(i);
                flatPos.setXYZ(i, x, 0, z);
            }

            const spherePos = basePos.clone();
            const temp = new THREE.Vector3();
            for (let i = 0; i < spherePos.count; i++) {
                temp.fromBufferAttribute(basePos, i).normalize().multiplyScalar(1.5);
                spherePos.setXYZ(i, temp.x, temp.y, temp.z);
            }

            baseGeom.morphAttributes.position = [flatPos, spherePos];

            const mat = new THREE.MeshNormalMaterial({ morphTargets: true });
            morphMesh = new THREE.Mesh(baseGeom, mat);
            morphScene.add(morphMesh);

            // sound on first click
            window.addEventListener("click", () => {
                const audio = document.getElementById("nos2");
                audio.volume = 0.6;
                audio.play().catch(() => { });
            }, { once: true });

            window.addEventListener("resize", resizeRenderer);
            window.addEventListener("mousedown", onMouseDown);
            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);

            animateMorph();
        }

        function animateMorph() {
            requestAnimationFrame(animateMorph);
            const t = morphClock.getElapsedTime();

            morphMesh.morphTargetInfluences[0] = Math.max(0, Math.sin(t));
            morphMesh.morphTargetInfluences[1] = Math.max(0, Math.sin(t - Math.PI / 2));

            if (!morphDrag) {
                morphMesh.rotation.y += 0.005;
                morphMesh.rotation.x += 0.003;
            }

            morphRenderer.render(morphScene, morphCamera);
        }

        function onMouseDown(e) {
            morphDrag = true;
            morphLastX = e.clientX;
            morphLastY = e.clientY;
        }

        function onMouseMove(e) {
            if (!morphDrag) return;
            const dx = e.clientX - morphLastX;
            const dy = e.clientY - morphLastY;

            morphMesh.rotation.y += dx * 0.01;
            morphMesh.rotation.x += dy * 0.01;

            morphLastX = e.clientX;
            morphLastY = e.clientY;
        }

        function onMouseUp() {
            morphDrag = false;
        }

        function resizeRenderer() {
            if (!morphRenderer || !morphCamera) return;
            morphRenderer.setSize(window.innerWidth, window.innerHeight);
            morphCamera.aspect = window.innerWidth / window.innerHeight;
            morphCamera.updateProjectionMatrix();
        }

        window.addEventListener("load", initMorph);
    </script>
</body>

</html>